# AtCoder Contest Knowledge
## List
---
| Contest | Problem | Result | Knowledge |
| :-      | :-      | :-     | :-        |
| abc003  | C       | AC     | 規則性を見つけてシミュレーション. 簡単. |
| abc005  | C       | AC     | 簡単. |
| abc011  | C       | AC     | 複雑な2次元DPで解いたが、想定解はシンプル1次元DPだった. DPはちゃんと勉強すべし. |
| abc035  | B       | AC     | 簡単. 45度回転させるやり方を会得するほうが良いかも. |
| abc052  | D       | AC     | 簡単.     |
| abc062  | C       | AC     | 場合分け問題. 簡単! |
| abc064  | D       | AC     | 簡単.     |
| abc069  | D       | AC     | 簡単.     |
| abc070  | D       | AC     | ダイクストラを覚えた! ただ、想定解はdfsだったみたい. 閉路のない向こうグラフである点から各点への最短路はO(N)で求まる. |
| abc074  | C       | AC     | 1次元DPができた! だけど、想定解は全探索. 制約の小ささに注目すべし.     |
| abc079  | D       | AC     | ワーシャルフロイドを覚えた. ただし、意味はまだ理解していない. dpが必要のよう. 問題はdfsで解いた.    |
| abc084  | D       | AC     | 素数判定+累積和. エラトステネスの篩を会得した. |
| abc085  | D       | AC     | ルールの見方を変える. |
| abc088  | D       | AC     | BFSは得意! |
| abc090  | D       | AC     | 楽勝! |
| abc094  | D       | AC     | Combinationの性質の問題. サンプル以外のケースもちゃんと考慮すべすし. |
| abc099  | C       | 解説AC | めちゃ難しかったが、DPの基本問題という感じ. |
| abc104  | C       | 解説AC | 答えになりうるパターンを全網羅する. |
| abc108  | C       | 解説AC | * |
| abc105  | C       | 解説AC | 全然理解できず. いつかやり直す. |
| abc112  | D       | 解説AC | * |
| abc115  | D       | AC     | 再帰の問題. 十分に理解できているかというと微妙だが、ざっくりとは理解した. |
| abc119  | C       | 解説AC | dfsによる全探索. 明確にグラフになってない場合でも抽象的なグラフを想像してdfsする. 何を網羅するかをよく考えること. 要復習. |
| abc121  | D       | 解説AC | * |
| abc123  | C       | 解説AC | ボトルネックとなる場所を考えること. |
| abc125  | D       | AC     | 思いつき. |
| abc127  | D       | AC     | priority_queueをうまく使えるとよし. |
| abc129  | D       | AC     | 実装力の問題. 意外と想定解も愚直だった. |
| abc130  | D       | AC     | 累積和+2分探索. しゃくとり法を学んだ. |
| abc132  | D       | AC     | n個の玉をkグループに分ける分け方は、nCk通り. |
| abc133  | D       | 解説AC | 1個決まれば連鎖的に全部決まる. |
| abc134  | D       | 解説AC | $\sum^{n}_{x=1}\frac{1}{x}$のオーダはO($\log{x}$)くらいなので、倍数を順になめる処理はそんなに遅くない. |
| abc139  | D       | AC | 試してみることが大事. 結果が最大となるのはどのような場合か、を考えると証明ができる. |
| abc142  | D       | 解説AC | A,Bの公約数はgcd(A, B)の約数(素因数の表を考える). |
| abc165  | C       | AC | dfsによる組み合わせ全探索. 少し時間がかかったが、慣れた. |
| abc165  | D       | 解説AC | * |
| abc169  | D       | AC | 素因数分解ができればOK. ライブラリあり! |
| abc171  | E       | AC | xorの性質はok. |
| abc172  | D       | 解説AC | 約数を考えるときは倍数を考えること. また、エラトステネスの篩によるシンプル解放もあり. |
| abc174  | C       | 解説AC | 余りの数列を考えるべし. |
| abc192  | D       | 解説AC | 問題をよく読むこと. 2分探索は正しく実装できるみたい. |
| abc194  | C       | AC | 式変形を頑張ってAC. シグマの式変形に慣れるとなお良し. 想定解は、分布を事前に調べて値を回す. |
| abc194  | D       | 解説AC | 確率・期待値については、勉強しなおすのが早いかもしれない. この問題については、以下の事実を抑えておくべき. 「確率pで成功する試行を成功するまで行うときの試行回数の期待値は1/pとなる」. あとは、これがN-1になるまで繰り返すだけ. |
| abc194  | E       | 解説AC | なんとなく方針は立てられていたが、想定解はもう少しエレガントだった. 最小値を求めればよいだけ、という点に注目すべきだった. |
| arc006  | B       | AC | 簡単. 空白を含む文字列を1行まとめて読む方法を覚えた. |
| arc009  | B       | AC | 問題をよく読むこと. 2分探索は正しく実装できるみたい. |
| arc043  | A       | AC | 算数を頑張るだけ. |
| arc114  | B       | 解説AC | 関数が出てきたら有向グラフ(functional graph)を考えると良い. この問題に関して言えば、閉路の数の数え上げ問題に落としこめるかが鍵. さらに、閉路の数が連結成分と同じであることに気づくことができればUnionFindが使えて実装が簡単. |
| agc011  | A       | AC | シミュレーション的な感じ. 愚直にやるだけ. |
| agc018  | A       | 解説AC | 複数の値の約数や素因数を考えるときはgcdも考えてみよう. 問題の見てgcdっぽいなと閃かないのがよくないぞ. |
| agc017  | A       | AC | modなしcombinationを使って解けたが、想定解はもっとエレガントだった. combinationは、modをとらない場合はオーバーフローさせずに計算するのが意外と難しいので、その場合はあまり想定解にはならないのかな. |
| dwango2015-prelims| B      | AC | しゃくとり法?的な感じ. |
| sumitrust2019 | D | AC | 簡単. 反対側から充てる感じ. |
| code-festival-2015-morning-middle | A | AC | 簡単だが、コーナーケースに注意! |
| nikkei2019-2-qual | B | 解説AC | 簡単だが、コーナーケースのWAが取れずタイムアップ. ちゃんとあり得るケースを網羅的に考える必要あり(それができれば苦労しない). |
| ddcc2020-qual | C | 解説AC | やり方すら閃かず. 想定解も実装がめちゃ重くて時間かかった. |
## Knowledge
---
### *abc108-C
以下のようなことを学んだ.
1) 余りで全網羅する手法
2) Kで割った余りがxになるような数を事前に数え上げておくことで計算を高速化できる.

O(1)で解く方法もあるが、modの計算に慣れてないせいか知らない法則があるせいか解説をあまり理解できなかったため一旦スルーした。modは一度ちゃんと勉強したほうが良い.

### *abc121-D
なんとなく方針は浮かんでいたが、うまく実装できず。以下の2)と3)の知識が足りなかった.
1) XORはビット単位で独立に計算可能
2) A^B=C <=> C^A=B
3) A~Bまでを考えるとき、0~B - 0~A-1みたいなのを考えるのが有効. 累積和も同様の考え方. 今回はxorなので、-でなくxorをとる.

### *abc165-D
1) floor(a/b)は以下のように表せる.
  floor(a/b) = (a - a % b) / b (aの余りが出る部分を先に引き算している)
2) 加減乗算でmodをとる順番は任意であることを利用して式変形を行う.
  ax % b = (a * (x % b)) % b

1,2)より、下のように式変形することができる.
floor(Ax/B) - A*floor(x/B)<br>
= (Ax - Ax % B) / B - (A * (x - x % B)) / B<br>
= ((Ax - Ax % B) - (A * (x - x % B))) / B<br>
= (-Ax%B + A*(x%B)) / B<br>
= (A*(x%B) - Ax%B) / B<br>
= (A*(x%B) - A*(x%B)%B) / B (2より)<br>
= floor(A*(x%B) / B) (1を逆向きに使う)<br>

よって、A, Bは定数なので、x%Bを最大化するxを選べば良い.

また、同じ式はx=pB+q(0<=q<B)と置くことでより簡単に求まる.<br>
floor(Ax/B) - A*floor(x/B)<br>
= floor(A(pB+q)/B) - A*floor((pB+q)/B)<br>
= floor(A(pB+q)/B) - A*p<br>
= floor((ApB+Aq)/B) - A*p<br>
= floor(Ap+(Aq/B)) - A*p<br>
= Ap + floor(Aq/B) - A*p (Bで割らない部分はfloorの外に出せる.)<br>
= floor(Aq/B)<br>
= floor(A*(x%B)/B) (qは余りなので、q=x%B)<br>

## Sample
---
$\sum^{n}_{k=1}k$

$\frac{1}{x}$

$x^{2}$